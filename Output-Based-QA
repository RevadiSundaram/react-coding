# Output Based Questions
# 1. 
```js
console.log("start");
    const promise1 = new Promise((resolve, reject) => {
        console.log(1);
        resolve(2);
    } )
    promise1.then((res) => {
        console.log(res);
    })
    console.log("end");
```
Output:
- start
- 1 (Because inside Promise it executes sync code)
- end
- 2

Explanation:
- JS will execute sync code first and then async code
- JS engine executes line by line.

# 2.
```js
    console.log("start");
    const promise1 = new Promise((resolve, reject) => {
        console.log(1);
        resolve(2);
        console.log(3);
    } )
    promise1.then((res) => {
        console.log(res);
    })
    console.log("end");
```
Output:
- start
- 1
- 3 (only async code will be kept in callback queue)
- end
- 2

# 3. 
```js
console.log("start");
    const promise1 = new Promise((resolve, reject) => {
        console.log(1);
        console.log(3);
    } )
    promise1.then((res) => {
        console.log("Result",res);
    })
    console.log("end");
```
Output:
- start
- 1
- 3
- end 

Explanation:
- Since there is no resolve it will not go to the .then() block 

# 4.
```js
    console.log("start");
    const func = () => new Promise((resolve, reject) => {
        console.log(1);
        resolve("success");
    } );
    console.log("Middle")
    func().then((res) => {
        console.log(res);
    })
    console.log("end");
```
Output:
- start
- Middle
- 1
- end
-  sucess

# 5.
<img src="image.png" width="600px" />
![alt text](<Screenshot 2024-10-06 at 3.11.24â€¯PM.png>)

Output:
- success
- defeat
- error
- Error Caught
- Sucess: test

# 6. Write first promise and write second promise, which resolve first promise
resolve second promise and print first promise.

```js
const firstPromise = new Promise((resolve, reject) => {
        resolve("First");
    })

    const secondPromise = new Promise((resolve, reject) => {
        resolve(firstPromise);
    })

    secondPromise.then((res) => {
        return res
    }).then((res) => console.log(res));
```

# 7. Rewrite using async/await

<img src="image-1.png" width="600px" />

Ans:
```js
const loadJson =  async(url) =>{
        let response = await fetch(url);
        if (response.status == 200){
            let json = await response.json();
            return json;
        }
        throw new Error(response.status)
    }
    loadJson("https.//fakeurl.com/no-such-user.json").catch((err) => console.log(err));
```

# 8. Write Promise Recursively

<img src="image-2.png" width="600px" />

# 9. Make the form triggering first, then button, then div

<img src="image-3.png" width="600px" />
<img src="image-4.png" width="600px" />

Ans:
- Make form -> capture:true

# 10. Create a Modal which closes by clicking on Negative space (space outside the modal)

<img src="image-6.png" width="600px" />

# 11. Debouncing
- Create a button UI and debounce as follows:
- Show "Button Pressed <X> Times" every time button is pressed.
- Increase "Triggered <Y> Times" count after 800ms of debounce

# 12. Map, Filter and Reduce

```js
    const students = [
        {name: "Piyush", rollNum: 31, marks: 80},
        {name: "Jeny", rollNum: 15, marks: 69},
        {name: "Kushal", rollNum: 16, marks: 35},
        {name: "Divya", rollNum: 7, marks: 55}
    ]
    
    //Question - Return names with capital

    let capital = students.map((stu) => stu.name.toUpperCase());
    // console.log(capital);

    //Question - Return only details of those who scored more than 60 marks

    let mark = students.filter((stu) => stu.marks > 60);
    // console.log(mark);

    //Question - More than 60 marks and rollnum greater than 15

    let both = students.filter((stu) => (stu.marks > 60) && (stu.rollNum > 15));
    // console.log(both);

    //Question - Sum of marks of all students
    let sum = students.reduce(((acc, cur) => acc + cur.marks),0);
    // console.log(sum);

    //Question - Return only names of students who scored more than 60

    let name = students.filter((stu) => stu.marks > 60).map((stu) => stu.name);
    // console.log("names ", name);

    //Question - Return total marks for students with marks greater than 60 
    // after 20 marks have been added to those who scored less than 60

    let total = students.map((stu) => {
        if(stu.marks < 60){
            stu.marks = stu.marks+20;
        }
        return stu;
        
    }).filter(stu => stu.marks > 60)
    .reduce((acc, cur) => acc+cur.marks,0);
    console.log(total)
```

# 13. Function Scope

- if var then
```js
    for(var i=0; i<5;i++){
        setTimeout(function (){
            console.log(i);
        }, i*1000);
    }
```
Output:
5 5 5 5 5
- If let
```js
    for(let i=0; i<5;i++){
        setTimeout(function (){
            console.log(i);
        }, i*1000);
    }
```
Output:
0 1 2 3 4
Solution:
- Var doesnt have block scope
- let has block scope

# Output?
```js
    var x=21;
    var fun = function(){
        console.log(x);
        var x=20;
    }
    fun();
```
Output:
undefined
- Bcoz if we have the same variable in the local scope it doesnt check the global scope for var

# Output?
```js
    const fn = (a, ...num, x,y) =>{
        console.log(x,y);
    }
    fun(5,6,3,2);
```
Output: Error - Rest operator should be last 

#
```js
    const fn = (a,x,y,...num) =>{
        console.log(x,y);
        console.log(num);
    }
    fn(5,6,3,2,1,0);
```
Output: 
- 6,3
- 2,1,0

# Output?
```js
    let count = 0;
    (function printCount(){
        if(count === 0){
            let count = 1; //shadowing
            console.log(count); //1
        }
        //count = 0
        console.log(count); //0
    })();
```
Output: 1 0

# write a function which allows you to do the below
```js
    var addSix = createBase(6);
    addSix(10);
    addSix(21);
```
```js
    function createBase(num){
        return function(innerNum){
            console.log(num+innerNum)
        }
    }
    var addSix = createBase(6);
    addSix(10); //return 16
    addSix(21); //retuns 27
```
# Time Optimization
```js
    function find(index){
        let a = [];
        for(let i=0; i< 1000000; i++){
            a[i] = i*i;
        }
        console.log(a[index]);
    }
    console.time("6");
    find(6);
    console.timeEnd("6");
    console.time("50");
    find(50);
    console.timeEnd("50")
```
- After Optimization
```js
    function find(){
        let a = [];
        for(let i=0; i< 1000000; i++){
            a[i] = i*i;
        }
        return function(index){
            console.log(a[index]);
        }
        
    }
    const closure = find();
    console.time("6");
    closure(6);
    console.timeEnd("6");
    console.time("50");
    closure(50);
    console.timeEnd("50")
```
# setTimeout Output
```js
    for(var i=0; i<3; i++){
        setTimeout(function log(){
            console.log(i);
        },i * 1000)
    }
```
Output: 3 3 3
- Bcoz var is not block scope, var is function scope
- So everytime value of i changes, it will increase and last value is 3 so after that it runs the setTimeOut block, so 3 is printed 3 times after 3000ms
```js
    for(let i=0; i<3; i++){
        setTimeout(function log(){
            console.log(i);
        },i * 1000)
    }
```
Output: 0 1 2
- Bcoz let is block scope
- Storage of value
```js
{0} {1} {2}
```
- So after iteration is done, in setTimeout block it refers the each reference of i and prints it after each i ms
- Using only var make output of 0 1 2
```js
    for(var i=0; i<3; i++){
        function inner(i){
        setTimeout(function log(){
            console.log(i);
        },1000);
        }
        inner(i);
    }
```
- Now with closure we can achieve this
- it will create a whole memory for everytime the function runs and gives us results 0 1 2

# Using Closure to create private counter


# Multiply each value by 2
```js
  let nums = {
    a: 100,
    b: 200,
    title: "Name is",
  }
  multiply(nums);

  function multiply(obj){
    for( key in obj){
      if(typeof obj[key] === "number"){
          obj[key] = obj[key] * 2;
      }
    }
  }
  console.log(nums);
```
Output: 200, 400, Name is

# Output?
```js
  const a = {};
  const b = {key: "b"};
  const c = {key: "c"};

  a[b] = 123; // a["[object Object]"] = 123
  a[c] = 456; //a["[object Object]"] = 456
  console.log(a);
  console.log(a[b]);
```
Output: 456

- Object cannot be converted into a key unless it is a string
- When it tried to assign 456 it overrides, so we got an output 456
